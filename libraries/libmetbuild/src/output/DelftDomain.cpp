// MIT License
//
// Copyright (c) 2020 ADCIRC Development Group
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Author: Zach Cobell
// Contact: zcobell@thewaterinstitute.org
//
#include "DelftDomain.h"

#include <utility>

#include "boost/algorithm/string.hpp"
#include "boost/format.hpp"

using namespace MetBuild;

DelftDomain::DelftDomain(const MetBuild::Grid *grid,
                         const MetBuild::Date &startDate,
                         const MetBuild::Date &endDate, unsigned int time_step,
                         std::string filename,
                         std::vector<std::string> variables)
    : m_baseFilename(std::move(filename)),
      m_variables(std::move(variables)),
      OutputDomain(grid, startDate, endDate, time_step) {}

DelftDomain::~DelftDomain() {
  for (auto &s : m_ofstreams) {
    s.close();
  }
}

void DelftDomain::open() {
  this->m_filenames.reserve(m_variables.size());
  this->m_ofstreams.reserve(m_variables.size());
  for (const auto &v : m_variables) {
    std::string filename, variableName, units;
    std::tie(filename, variableName, units) = this->variableToFields(v);
    this->m_filenames.push_back(filename);
    this->m_ofstreams.emplace_back(this->m_filenames.back());
    this->writeHeader(m_ofstreams.back(), variableName, units);
  }
}

void DelftDomain::close() {
  for (auto &s : m_ofstreams) {
    s.close();
  }
}

int DelftDomain::write(
    const MetBuild::Date &date,
    const MetBuild::MeteorologicalData<1, MetBuild::MeteorologicalDataType>
        &data) {
  return this->writeField(m_ofstreams[0], date, data[0]);
}

int DelftDomain::write(
    const MetBuild::Date &date,
    const MetBuild::MeteorologicalData<3, MetBuild::MeteorologicalDataType>
        &data) {
  int return_val = 0;
  for (size_t i = 0; i < 3; ++i) {
    return_val += this->writeField(m_ofstreams[i], date, data[i]);
  }
  return return_val;
}

std::tuple<std::string, std::string, std::string> DelftDomain::variableToFields(
    const std::string &variable) {
  auto v2 = boost::to_lower_copy(variable);
  if (variable == "wind_x") {
    return {this->m_baseFilename + ".amu", "x_wind", "m s-1"};
  } else if (variable == "wind_y") {
    return {this->m_baseFilename + ".amv", "y_wind", "m s-1"};
  } else if (variable == "pressure") {
    return {this->m_baseFilename + ".amp", "air_pressure", "mb"};
  } else if (variable == "temperature") {
    return {this->m_baseFilename + ".amt", "temperature", "k"};
  } else if (variable == "humidity") {
    return {this->m_baseFilename + ".amh", "relative_humidity", "%"};
  } else if (variable == "ice") {
    return {this->m_baseFilename + ".ami", "ice_concentration", "%"};
  } else if (variable == "rain") {
    return {this->m_baseFilename + ".amr", "precipitation", "mm s-1"};
  } else {
    metbuild_throw_exception("Invalid variable specified.");
    return {};
  }
}

void DelftDomain::writeHeader(std::ofstream &stream,
                              const std::string &variable,
                              const std::string &units) {
  // clang-format off
  stream << std::string("### START OF HEADER\n") +
            "### This file generated by MetGet\n" +
            "### File generated: " + Date::now().toString() + "\n" +
            "FileVersion      = 1.03\n" +
            "filetype         = meteo_on_equidistant_grid\n" +
            "NODATA_value     = "+boost::str(boost::format("%0.1f") % -999.0) + "\n" +
            "n_cols           = " + boost::str(boost::format("%d")%this->grid()->ni())+"\n"+
            "n_rows           = " + boost::str(boost::format("%d")%this->grid()->nj())+"\n"+
            "grid_unit        = deg\n" +
            "x_llcenter       = " + boost::str(boost::format("0.6f")%this->grid()->bottom_left().x())+"\n"+
            "y_llcenter       = " + boost::str(boost::format("0.6f")%this->grid()->bottom_left().y())+"\n"+
            "dx               = " + boost::str(boost::format("%0.4f")%this->grid()->dx())+"\n"+
            "dy               = " + boost::str(boost::format("%0.4f")%this->grid()->dy())+"\n"+
            "n_quantity       = 1\n"+
            "quantity_1       = "+variable+"\n"+
            "unit_1           = "+units+"\n"+
            "### END OF HEADER\n";
  // clang-format on
}

template <typename T>
int DelftDomain::writeField(std::ofstream &stream, const MetBuild::Date &date,
                            const std::vector<std::vector<T>> &data) {
  double hours =
      static_cast<double>(date.toSeconds() - this->startDate().toSeconds()) /
      3600.0;
  stream << "TIME = " << boost::str(boost::format("%0.6f") % hours)
         << " hours since " << this->startDate().toString() + " +00:00\n";
  for (const auto &r : data) {
    for (const auto &c : r) {
      stream << boost::str(boost::format("%0.6f ") % c);
    }
    stream << "\n";
  }
  return 0;
}
