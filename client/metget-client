#!/usr/bin/env python3
################################################################################
# MetGet Client
#
# This file is part of the MetGet distribution (https://github.com/waterinstitute/metget).
# Copyright (c) 2023, The Water Institute
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

import argparse
import json
import os
import time
from datetime import datetime
from typing import Tuple

import requests

# Available metget models
AVAILABLE_MODELS = {
    "gfs": "gfs-ncep",
    "gefs": "gefs-ncep",
    "nam": "nam-ncep",
    "hwrf": "hwrf",
    "hrrr": "hrrr-conus",
    "coamps": "coamps-tc",
    "nhc": "nhc",
}

# Available metget variables
AVAILABLE_VARIABLES = {"wind_pressure", "rain", "temperature", "humidity", "ice"}

# Available metget formats
AVAILABLE_FORMATS = {
    "raw",
    "ascii",
    "owi-ascii",
    "owi-netcdf",
    "hec-netcdf",
    "delft3d",
}


class SpinnerLogger:
    """
    Class to handle the spinner animation and logging
    """

    def __init__(self):
        """
        Constructor
        """
        from sys import stdout

        try:
            from halo import Halo

            self.__is_tty = stdout.isatty()
        except ImportError:
            if stdout.isatty():
                print(
                    "[WARNING]: Halo package not found. Disabling animation.",
                    flush=True,
                )
            self.__is_tty = False

        self.__current_text = SpinnerLogger.standard_log(0, "initializing")

        if self.__is_tty:
            self.__spinner = Halo(
                text=self.__current_text,
                spinner="dots",
                placement="left",
            )
            self.__spinner.color = self.__spinner.text_color

    @staticmethod
    def __time_str() -> str:
        """
        Returns the current time in UTC

        Returns:
            str: Current time in UTC
        """
        return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

    def start(self, text: str = None) -> None:
        """
        Starts the spinner animation

        Args:
            text (str, optional): Text to display. Defaults to None.

        Returns:
            None
        """
        if text is not None:
            self.__current_text = text
        if self.__is_tty:
            self.__spinner.start(self.__current_text)
        else:
            SpinnerLogger.__standard_print(self.__current_text)

    def set_text(self, text: str) -> None:
        """
        Sets the text to display in the spinner

        Args:
            text (str): Text to display

        Returns:
            None
        """
        self.__current_text = text
        if self.__is_tty:
            self.__spinner.text = self.__current_text
        else:
            SpinnerLogger.__standard_print(self.__current_text)

    def succeed(self, text: str = None) -> None:
        """
        Stops the spinner animation and displays a success message

        Args:
            text (str, optional): Text to display. Defaults to None.

        Returns:
            None
        """
        if text is not None:
            self.__current_text = text

        if self.__is_tty:
            self.__spinner.succeed(self.__current_text)
        else:
            SpinnerLogger.__standard_print(self.__current_text)

    def info(self, text: str = None) -> None:
        """
        Displays an info message in the spinner

        Args:
            text (str, optional): Text to display. Defaults to None.

        Returns:
            None
        """
        if text is not None:
            self.__current_text = text

        if self.__is_tty:
            self.__spinner.info(self.__current_text)
        else:
            SpinnerLogger.__standard_print(self.__current_text)

    def fail(self, text: str = None) -> None:
        """
        Stops the spinner animation and displays a failure message

        Args:
            text (str, optional): Text to display. Defaults to None.

        Returns:
            None
        """
        if text is not None:
            self.__current_text = text

        if self.__is_tty:
            self.__spinner.fail(self.__current_text)
        else:
            SpinnerLogger.__standard_print(self.__current_text)

    @staticmethod
    def __standard_print(text: str) -> None:
        """
        Prints the given text to stdout

        Args:
            text (str): Text to print

        Returns:
            None
        """
        print(text, flush=True)

    @staticmethod
    def standard_log(count: int, status: str) -> str:
        """
        Returns a standard log message

        Args:
            count (int): Number of requests
            status (str): Status of the request

        Returns:
            str: Standard log message
        """
        return "[{:s}]: Checking request status...(n={:d}): {:s}".format(
            SpinnerLogger.__time_str(), count, status
        )


def valid_datetime_type(arg_datetime_str: str) -> datetime:
    """
    Checks if the given datetime string is valid

    Args:
        arg_datetime_str (str): Datetime string to check

    Returns:
        datetime: Datetime object if valid
    """
    try:
        return datetime.strptime(arg_datetime_str, "%Y-%m-%d %H:%M")
    except ValueError:
        msg = "Given DateTime ({0}) not valid! Expected format: 'YYYY-MM-DD HH:mm'".format(
            arg_datetime_str
        )
        raise argparse.ArgumentTypeError(msg)


def parse_domain_data(domain_list: list, level: int, tau: int) -> dict:
    """
    Parses the domain data from the given list and returns a dictionary

    Args:
        domain_list (list): List of domain data
        level (int): Level of the domain
        tau (int): Forecast skipping time

    Returns:
        dict: Dictionary containing the domain data
    """

    storm = None
    ensemble_member = None
    basin = None
    advisory = None

    model = domain_list[0]
    if "hwrf" in model:
        storm = model.split("-")[1]
        model = "hwrf"
    elif "coamps" in model:
        storm = model.split("-")[1]
        model = "coamps"
    elif "gefs" in model:
        ensemble_member = model.split("-")[1]
        model = "gefs"
    elif "nhc" in model:
        keys = model.split("-")
        basin = keys[1]
        storm = keys[2]
        advisory = keys[3]
        model = "nhc"

    res = float(domain_list[1])
    x0 = float(domain_list[2])
    y0 = float(domain_list[3])
    x1 = float(domain_list[4])
    y1 = float(domain_list[5])

    if model not in AVAILABLE_MODELS.keys():
        raise RuntimeError("Specified model '" + model + "' is not available")

    xmax = max(x0, x1)
    xmin = min(x0, x1)
    ymax = max(y0, y1)
    ymin = min(y0, y1)
    res = abs(res)
    if res <= 0:
        raise RuntimeError("Specified model resolution is invalid")

    if model == "hwrf":
        return {
            "name": AVAILABLE_MODELS[model] + "-" + storm,
            "service": AVAILABLE_MODELS[model],
            "storm": storm,
            "x_init": xmin,
            "y_init": ymin,
            "x_end": xmax,
            "y_end": ymax,
            "di": res,
            "dj": res,
            "level": level,
        }
    elif model == "coamps":
        return {
            "name": AVAILABLE_MODELS[model] + "-" + storm,
            "service": AVAILABLE_MODELS[model],
            "storm": storm,
            "tau": tau,
            "x_init": xmin,
            "y_init": ymin,
            "x_end": xmax,
            "y_end": ymax,
            "di": res,
            "dj": res,
            "level": level,
        }
    elif model == "gefs":
        return {
            "name": model,
            "service": AVAILABLE_MODELS[model],
            "ensemble_member": ensemble_member,
            "x_init": xmin,
            "y_init": ymin,
            "x_end": xmax,
            "y_end": ymax,
            "di": res,
            "dj": res,
            "level": level,
        }
    elif model == "nhc":
        return {
            "name": model,
            "service": AVAILABLE_MODELS[model],
            "basin": basin,
            "storm": storm,
            "advisory": advisory,
            "x_init": xmin,
            "y_init": ymin,
            "x_end": xmax,
            "y_end": ymax,
            "di": res,
            "dj": res,
            "level": level,
        }
    else:
        return {
            "name": model,
            "service": AVAILABLE_MODELS[model],
            "x_init": xmin,
            "y_init": ymin,
            "x_end": xmax,
            "y_end": ymax,
            "di": res,
            "dj": res,
            "level": level,
        }


def make_metget_request(
    endpoint: str, apikey: str, request_json: dict
) -> Tuple[str, int]:
    """
    Makes a request to the MetGet API and returns the data id and status code

    Args:
        endpoint (str): MetGet API endpoint
        apikey (str): MetGet API key
        request_json (dict): Request JSON

    Returns:
        Tuple[str, int]: Data id and status code
    """
    headers = {"x-api-key": apikey}
    r = requests.post(endpoint + "/build", headers=headers, json=request_json)
    if r.status_code != 200:
        raise RuntimeError(
            "Request to MetGet was returned status code = " + str(r.status_code)
        )
    return_data = json.loads(r.text)
    data_id = return_data["body"]["request_id"]
    status_code = return_data["statusCode"]
    if status_code != 200:
        with open("metget.debug", "a") as f:
            f.write("[WARNING]: MetGet returned status code " + str(status_code) + "\n")
            f.write(str(return_data["body"]["error_text"]))
    return data_id, status_code


def download_metget_data(
    data_id: str,
    endpoint: str,
    apikey: str,
    sleep_time: int,
    max_wait: int,
    api_version: int,
) -> None:
    """
    Downloads the data from the MetGet API

    Args:
        data_id (str): Data id
        endpoint (str): MetGet API endpoint
        apikey (str): MetGet API key
        sleep_time (int): Time to sleep between status checks
        max_wait (int): Maximum time to wait for data to appear
        api_version (int): MetGet API version

    Returns:
        None
    """
    from datetime import datetime, timedelta

    # ...Status check
    headers = {"x-api-key": apikey}

    # ...Wait time
    end_time = datetime.utcnow() + timedelta(hours=max_wait)

    # ...Timing information
    request_start_time = datetime.utcnow()

    # ...Wait for request data to appear
    tries = 0
    data_ready = False
    status = None

    spinner = SpinnerLogger()
    print("Waiting for request id {:s}".format(data_id), flush=True)
    spinner.start()

    return_data = None
    data_url = None

    while datetime.utcnow() <= end_time:
        tries += 1
        try:
            data_url, status = check_metget_status(
                data_id, endpoint, headers, api_version
            )
            spinner.set_text(SpinnerLogger.standard_log(tries, status))
            if status == "completed":
                spinner.succeed()
                # ...Parse the return to get data
                data_ready = True
                flist_url = data_url + "/filelist.json"
                u = requests.get(flist_url)
                if u.status_code == 200:
                    return_data = json.loads(u.text)
                    with open("filelist.json", "w") as jsonfile:
                        jsonfile.write(
                            json.dumps(return_data, indent=2, sort_keys=True)
                        )
                    break
            elif status == "error":
                spinner.fail("Request could not be completed")
                return
            else:
                time.sleep(sleep_time)
                continue
        except KeyboardInterrupt:
            spinner.fail("Process was ended by the user")
            raise

    # ...Download files
    if data_ready:
        file_list = return_data["output_files"]
        for f in file_list:
            time_stamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
            spinner.start("[{:s}]: Getting file: {:s}".format(time_stamp, f))
            with requests.get(data_url + "/" + f, stream=True) as r:
                r.raise_for_status()
                with open(f, "wb") as wind_file:
                    for chunk in r.iter_content(chunk_size=8192):
                        wind_file.write(chunk)
            spinner.succeed()

        request_end_time = datetime.utcnow()
        request_duration = request_end_time - request_start_time
        hours, remainder = divmod(request_duration.total_seconds(), 3600)
        minutes, seconds = divmod(remainder, 60)
        spinner.succeed(
            "Elapsed time: {:d}h{:02d}m{:02d}s".format(
                int(hours), int(minutes), int(seconds)
            )
        )
    else:
        if status == "restore":
            print(
                "[WARNING]: Data for request "
                + data_id
                + " did not become ready before the max-wait time expired. You can rerun and ask for this request by id"
            )
        elif status == "running":
            print(
                "[WARNING]: Data for request "
                + data_id
                + " is still being constructed when the max-wait time expired. Please check on it later"
            )
        elif status == "queued":
            print(
                "[WARNING]: Data for request "
                + data_id
                + " is still queued. If this does not change soon, please contact an administrator"
            )
        else:
            print("[ERROR]: Data has not become available due to an unknown error")
        return


def check_metget_status(
    data_id: str, endpoint: str, headers: dict, api_version: int
) -> Tuple[str, str]:
    """
    Checks the status of a MetGet request

    Args:
        data_id (str): Data id
        endpoint (str): MetGet API endpoint
        headers (dict): HTTP headers
        api_version (int): MetGet API version

    Returns:
        Tuple[str, str]: Data url and status
    """
    response = None
    if api_version == 1:
        response = check_metget_status_v1(data_id, endpoint, headers)
    elif api_version == 2:
        response = check_metget_status_v2(data_id, endpoint, headers)
    json_response = json.loads(response)
    status = json_response["body"]["status"]
    data_url = json_response["body"]["destination"]
    return data_url, status


def check_metget_status_v1(data_id: str, endpoint: str, headers: dict) -> str:
    """
    Checks the status of a MetGet request using the v1 API

    Args:
        data_id (str): Data id
        endpoint (str): MetGet API endpoint
        headers (dict): HTTP headers

    Returns:
        str: response text
    """
    request_json = {"request": data_id}
    response = requests.post(endpoint + "/check", headers=headers, json=request_json)
    return response.text


def check_metget_status_v2(data_id: str, endpoint: str, headers: dict) -> str:
    """
    Checks the status of a MetGet request using the v2 API

    Args:
        data_id (str): Data id
        endpoint (str): MetGet API endpoint
        headers (dict): HTTP headers

    Returns:
        str: response text
    """
    request_params = {"request-id": data_id}
    response = requests.get(endpoint + "/check", headers=headers, params=request_params)
    return response.text


def main():
    """
    Main function for command line interface
    """
    import socket
    import json
    import getpass

    mlist = str()
    for m in AVAILABLE_MODELS.keys():
        if len(mlist) == 0:
            mlist += m
        else:
            mlist += ", " + m

    p = argparse.ArgumentParser(description="Make a request to MetGet")
    p.add_argument(
        "--domain",
        help="Wind domain specification. Model may be any of ["
        + mlist
        + "]. Resolution and corners are decimal degrees"
        " For HWRF/COAMPS, the model can be listed as 'hwrf-[stormname]' or 'coamps-[stormname]'."
        " For GEFS, the ensemble member can be specified as 'gefs-[ensemble_member]'. For NHC data"
        " specify as 'nhc-basin-storm_number-advisory_number' where basin is a two letter string denoting"
        " the basin (al, ep, wp), storm number is the id of the storm (not the name), and the advisory number"
        " is the advisory to use to build the merged data (or 0 for best-track data only).",
        nargs=6,
        metavar=("model", "resolution", "x0", "y0", "x1", "y1"),
        action="append",
    )
    p.add_argument(
        "--start",
        help="Start time",
        type=datetime.fromisoformat,
        metavar="YYYY-MM-DD hh:mm",
    )
    p.add_argument(
        "--end",
        help="End time",
        type=datetime.fromisoformat,
        metavar="YYYY-MM-DD hh:mm",
    )
    p.add_argument(
        "--timestep", help="Time step of winds in seconds", metavar="dt", type=int
    )
    p.add_argument(
        "--analysis", help="Generate analysis wind fields", action="store_true"
    )
    p.add_argument(
        "--multiple-forecasts",
        help="Allow the use of multiple forecast wind fields",
        action="store_true",
    )
    p.add_argument(
        "--initialization-skip",
        help="For COAMPS-TC, skip some initialization period of each forecast. "
        "This is considered a discard period where forecast times < [skip] hours are "
        "discarded when selecting the data",
        type=int,
        metavar="h",
        required=False,
        default=0,
    )
    p.add_argument("--output", help="Base name of output data", type=str, metavar="s")
    p.add_argument("--apikey", help="API key for access to MetGet", type=str)
    p.add_argument("--endpoint", help="MetGet API endpoint", type=str)
    p.add_argument(
        "--format",
        help="Output format (owi-ascii, owi-netcdf, hec-netcdf, delft3d)",
        metavar="f",
        default="owi-ascii",
    )
    p.add_argument(
        "--variable",
        help="Variable to request from MetGet (wind_pressure, rain, humidity, temperature, ice)",
        metavar="v",
        default="wind_pressure",
    )
    p.add_argument(
        "--check-interval",
        help="Time between status checks (default=10s)",
        metavar="t",
        default=10,
        type=float,
    )
    p.add_argument(
        "--max-wait",
        help="Maximum wait time for the request to complete in hours (default=24)",
        metavar="h",
        default=24,
        type=float,
    )
    p.add_argument(
        "--strict",
        action="store_true",
        help="Do not allow MetGet to make due with what it has. Force the response to match the request",
    )
    p.add_argument(
        "--backfill",
        action="store_true",
        help="Backfill data from lower priority domains",
        default=False,
    )
    p.add_argument(
        "--epsg",
        help="Coordinate system of the specified domain and output data (default: 4326)",
        required=False,
        metavar="#",
        type=int,
        default=4326,
    )
    p.add_argument("--dryrun", help="Perform dry run only", action="store_true")
    p.add_argument(
        "--request",
        help="Check on and download specified request id",
        type=str,
        metavar="request_id",
    )
    p.add_argument(
        "--compression",
        action="store_true",
        help="For ASCII based data formats, use gzip compression in the retreived files",
        default=False,
    )
    p.add_argument(
        "--save-json-request",
        action="store_true",
        help="Save the json request sent to the MetGet API as request.json",
        default=False,
    )
    p.add_argument(
        "--api-version",
        type=int,
        help="MetGet API version. Default is 1. When using the k8s MetGet API, this should be 2.",
    )

    args = p.parse_args()

    if not args.endpoint:
        if "METGET_ENDPOINT" not in os.environ:
            raise RuntimeError("No endpoint found.")
        else:
            endpoint = os.environ["METGET_ENDPOINT"]
    else:
        endpoint = args.endpoint

    if not args.apikey:
        if "METGET_API_KEY" not in os.environ:
            raise RuntimeError("No API key was found.")
        else:
            apikey = os.environ["METGET_API_KEY"]
    else:
        apikey = args.apikey

    if not args.api_version:
        if "METGET_API_VERSION" not in os.environ:
            api_version = 1
        else:
            api_version = int(os.environ["METGET_API_VERSION"])
    else:
        api_version = args.api_version

    # ...Check for required arguments
    if not args.request:
        if not args.start:
            print("[ERROR]: Must provide '--start'")
            exit(1)
        if not args.end:
            print("[ERROR]: Must provide '--end'")
            exit(1)
        if not args.timestep:
            print("[ERROR]: Must provice '--timestep'")
            exit(1)
        if not args.output:
            print("[ERROR]: Must provide '--output'")
            exit(1)

        # ...Building the request
        domains = []
        idx = 0
        for d in args.domain:
            j = parse_domain_data(d, idx, args.initialization_skip)
            domains.append(j)
            idx += 1

        if args.format not in AVAILABLE_FORMATS:
            print("ERROR: Invalid output format selected")
            exit(1)

        if args.format == "delft3d" or args.format == "hec-netcdf":
            if len(domains) > 1:
                print(
                    "[ERROR]: "
                    + args.format
                    + " does not support more than one domain."
                )
                exit(1)

        if args.variable not in AVAILABLE_VARIABLES:
            print("ERROR: Invalid variable selected")
            exit(1)

        request_from = getpass.getuser() + "." + socket.gethostname()
        request_data = {
            "version": "0.0.1",
            "creator": request_from,
            "background_pressure": 1013.0,
            "backfill": args.backfill,
            "nowcast": args.analysis,
            "multiple_forecasts": args.multiple_forecasts,
            "start_date": str(args.start),
            "end_date": str(args.end),
            "format": args.format,
            "data_type": args.variable,
            "time_step": args.timestep,
            "domains": domains,
            "compression": args.compression,
            "epsg": args.epsg,
            "filename": args.output,
        }
        if args.strict:
            request_data["strict"] = True
        if args.dryrun:
            request_data["dry_run"] = True

        if args.save_json_request:
            with open("request.json", "w") as f:
                f.write(json.dumps(request_data, indent=2))

        data_id, status_code = make_metget_request(endpoint, apikey, request_data)
        if not args.dryrun and status_code == 200:
            download_metget_data(
                data_id,
                endpoint,
                apikey,
                args.check_interval,
                args.max_wait,
                api_version,
            )
        else:
            print(status_code)

    else:
        download_metget_data(
            args.request,
            endpoint,
            apikey,
            args.check_interval,
            args.max_wait,
            api_version,
        )


if __name__ == "__main__":
    main()
