#!/usr/bin/env python3
################################################################################
# MetGet Client
#
# This file is part of the MetGet distribution (https://github.com/waterinstitute/metget).
# Copyright (c) 2023, The Water Institute
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Author: Zach Cobell, zcobell@thewaterinstitute.org
#
################################################################################


def main():
    """
    Main function for command line interface
    """
    import argparse
    import os
    from datetime import datetime
    from metgetclient.metgetclient import MetGetClient

    mlist = str()
    for m in MetGetClient.AVAILABLE_MODELS.keys():
        if len(mlist) == 0:
            mlist += m
        else:
            mlist += ", " + m

    p = argparse.ArgumentParser(description="Make a request to MetGet")
    p.add_argument(
        "--domain",
        help="Wind domain specification. Model may be any of ["
        + mlist
        + "]. Resolution and corners are decimal degrees"
        " For HWRF/COAMPS, the model can be listed as 'hwrf-[stormname]' or 'coamps-[stormname]'."
        " For GEFS, the ensemble member can be specified as 'gefs-[ensemble_member]'. For NHC data"
        " specify as 'nhc-basin-storm_number-advisory_number' where basin is a two letter string denoting"
        " the basin (al, ep, wp), storm number is the id of the storm (not the name), and the advisory number"
        " is the advisory to use to build the merged data (or 0 for best-track data only).",
        nargs=6,
        metavar=("model", "resolution", "x0", "y0", "x1", "y1"),
        action="append",
    )
    p.add_argument(
        "--start",
        help="Start time",
        type=datetime.fromisoformat,
        metavar="YYYY-MM-DD hh:mm",
    )
    p.add_argument(
        "--end",
        help="End time",
        type=datetime.fromisoformat,
        metavar="YYYY-MM-DD hh:mm",
    )
    p.add_argument(
        "--timestep", help="Time step of winds in seconds", metavar="dt", type=int
    )
    p.add_argument(
        "--analysis", help="Generate analysis wind fields", action="store_true"
    )
    p.add_argument(
        "--multiple-forecasts",
        help="Allow the use of multiple forecast wind fields",
        action="store_true",
    )
    p.add_argument(
        "--initialization-skip",
        help="For COAMPS-TC, skip some initialization period of each forecast. "
        "This is considered a discard period where forecast times < [skip] hours are "
        "discarded when selecting the data",
        type=int,
        metavar="h",
        required=False,
        default=0,
    )
    p.add_argument("--output", help="Base name of output data", type=str, metavar="s")
    p.add_argument("--apikey", help="API key for access to MetGet", type=str)
    p.add_argument("--endpoint", help="MetGet API endpoint", type=str)
    p.add_argument(
        "--format",
        help="Output format (raw, owi-ascii, owi-netcdf, generic-netcdf (hec-netcdf), delft3d)",
        metavar="f",
        default="owi-ascii",
    )
    p.add_argument(
        "--variable",
        help="Variable to request from MetGet (wind_pressure, rain, humidity, temperature, ice)",
        metavar="v",
        default="wind_pressure",
    )
    p.add_argument(
        "--check-interval",
        help="Time between status checks (default=10s)",
        metavar="t",
        default=10,
        type=float,
    )
    p.add_argument(
        "--max-wait",
        help="Maximum wait time for the request to complete in hours (default=24)",
        metavar="h",
        default=24,
        type=float,
    )
    p.add_argument(
        "--strict",
        action="store_true",
        help="Do not allow MetGet to make due with what it has. Force the response to match the request",
    )
    p.add_argument(
        "--backfill",
        action="store_true",
        help="Backfill data from lower priority domains",
        default=False,
    )
    p.add_argument(
        "--epsg",
        help="Coordinate system of the specified domain and output data (default: 4326)",
        required=False,
        metavar="#",
        type=int,
        default=4326,
    )
    p.add_argument("--dryrun", help="Perform dry run only", action="store_true")
    p.add_argument(
        "--request",
        help="Check on and download specified request id",
        type=str,
        metavar="request_id",
    )
    p.add_argument(
        "--compression",
        action="store_true",
        help="For ASCII based data formats, use gzip compression in the retreived files",
        default=False,
    )
    p.add_argument(
        "--save-json-request",
        action="store_true",
        help="Save the json request sent to the MetGet API as request.json",
        default=False,
    )
    p.add_argument(
        "--api-version",
        type=int,
        help="MetGet API version. Default is 1. When using the k8s MetGet API, this should be 2.",
    )
    p.add_argument("--version",action="store_true",help="Print the MetGetClient library version")

    args = p.parse_args()

    if args.version:
        print(MetGetClient.version())
        exit(0)

    if not args.endpoint:
        if "METGET_ENDPOINT" not in os.environ:
            raise RuntimeError("No endpoint found.")
        else:
            endpoint = os.environ["METGET_ENDPOINT"]
    else:
        endpoint = args.endpoint

    if not args.apikey:
        if "METGET_API_KEY" not in os.environ:
            raise RuntimeError("No API key was found.")
        else:
            apikey = os.environ["METGET_API_KEY"]
    else:
        apikey = args.apikey

    if not args.api_version:
        if "METGET_API_VERSION" not in os.environ:
            api_version = 1
        else:
            api_version = int(os.environ["METGET_API_VERSION"])
    else:
        api_version = args.api_version

    # ...Initialize the metget client
    client = MetGetClient(endpoint, apikey, api_version)

    # ...Check for required arguments
    if not args.request:
        if not args.start:
            print("[ERROR]: Must provide '--start'")
            exit(1)
        if not args.end:
            print("[ERROR]: Must provide '--end'")
            exit(1)
        if not args.timestep:
            print("[ERROR]: Must provice '--timestep'")
            exit(1)
        if not args.output:
            print("[ERROR]: Must provide '--output'")
            exit(1)

        output_format = MetGetClient.AVAILABLE_FORMATS[args.format]
        if output_format == "delft3d" or output_format == "hec-netcdf":
            if len(args.domain) > 1:
                print(
                    "[ERROR]: "
                    + args.format
                    + " does not support more than one domain."
                )
                exit(1)

        if args.variable not in MetGetClient.AVAILABLE_VARIABLES:
            print("ERROR: Invalid variable '{:s}' selected".format(args.variable))
            exit(1)

        if args.format not in MetGetClient.AVAILABLE_FORMATS.keys():
            print("ERROR: Invalid output format '{:s}' selected".format(args.format))
            exit(1)

        # ...Building the request
        request_data = MetGetClient.generate_request_json(
            analysis=args.analysis,
            multiple_forecasts=args.multiple_forecasts,
            start_date=args.start,
            end_date=args.end,
            format=output_format,
            data_type=args.variable,
            backfill=args.backfill,
            time_step=args.timestep,
            domains=MetGetClient.parse_command_line_domains(
                args.domain, args.initialization_skip
            ),
            compression=args.compression,
            epsg=args.epsg,
            filename=args.output,
            strict=args.strict,
            dry_run=args.dryrun,
            save_json_request=args.save_json_request,
        )

        data_id, status_code = client.make_metget_request(request_data)
        if not args.dryrun and status_code == 200:
            client.download_metget_data(
                data_id,
                args.check_interval,
                args.max_wait,
            )
        else:
            print(status_code)

    else:
        client.download_metget_data(
            args.request,
            args.check_interval,
            args.max_wait,
        )


if __name__ == "__main__":
    main()
